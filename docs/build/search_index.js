var documenterSearchIndex = {"docs":
[{"location":"ansätze/#Ansätze","page":"Ansätze","title":"Ansätze","text":"","category":"section"},{"location":"ansätze/","page":"Ansätze","title":"Ansätze","text":"H_A_Var","category":"page"},{"location":"ansätze/#QuantVarEntHam.H_A_Var","page":"Ansätze","title":"QuantVarEntHam.H_A_Var","text":"H_A_Var\n\nStruct to save the Yao AbstractBlocks and its matrix representation throughout the optimization.\n\nThe optimizing is only done with the matrices in matrices. blocks is only saved for convenient utiliy functions such as  printing the Entanglement Hamiltonian.\n\nFields\n\nblocks::Vector{AbstractBlock}: Containing each Hamiltonian Block as an Yao AbstractBlock.\nmatrices::Vector{Matrix{ComplexF64}}: Containing each Hamiltonian Block as a matrix.\n\n\n\n\n\n","category":"type"},{"location":"ansätze/","page":"Ansätze","title":"Ansätze","text":"H_A_BW(set::Settings)","category":"page"},{"location":"ansätze/#QuantVarEntHam.H_A_BW-Tuple{Settings}","page":"Ansätze","title":"QuantVarEntHam.H_A_BW","text":"H_A_BW(set::Settings)\n\nReturn an instance of type H_A_Var containing the Yao Blocks and its matrix representation.\n\nThe variational Ansatz follows the Bisognano-Wichmann-theorem. This function dispatches on the concrete subtypes of the abstract type Settings to get the correct variational Ansatz for the corresponding model. \n\nExample\n\nH_A_BW(set::Settings_TFIM) returns the variational Ansatz for the TFIM following the Bisognano-Wichmann-theorem.\n\n\n\n\n\n","category":"method"},{"location":"ansätze/","page":"Ansätze","title":"Ansätze","text":"H_A_not_BW(set::Settings) ","category":"page"},{"location":"ansätze/#QuantVarEntHam.H_A_not_BW-Tuple{Settings}","page":"Ansätze","title":"QuantVarEntHam.H_A_not_BW","text":"H_A_not_BW(set::Settings)\n\nReturn an instance of type H_A_Var containing the Yao Blocks and its matrix representation.\n\nThe variational Ansatz does not follow the Bisognano-Wichmann-theorem. This function dispatches on the concrete subtypes of the abstract type Settings to get the correct variational Ansatz for the corresponding model. \n\nExample\n\nH_A_not_BW(set::Settings_TFIM) returns the variational Ansatz for the TFIM following not following the Bisognano-Wichmann-theorem.\n\n\n\n\n\n","category":"method"},{"location":"functionality/#Functionality","page":"Functionality","title":"Functionality","text":"","category":"section"},{"location":"functionality/","page":"Functionality","title":"Functionality","text":"This section shows how all components come together to a running optimzation and serves as a walkthrough.","category":"page"},{"location":"functionality/#Walkthrough","page":"Functionality","title":"Walkthrough","text":"","category":"section"},{"location":"functionality/","page":"Functionality","title":"Functionality","text":"The backbones of this package are the concrete types of Settings i.e. the structs containing  the settings e.g. number of sites in the composite system N or subsystem N_A, observables observables, reduced density matrix ρ_A, etc...  For each lattice model there is an own subtype e.g. Settings_XXZ for the XXZ-model, which can  be conveniently constructed with a constructor e.g. XXZ. Second of all after choosing the lattice model, one needs to choose the variational Ansatz e.g H_A_BW, which returns a struct H_A_Var containing the Hamiltonian Blocks. To keep the code as short as possible for the user, this is passed to a function initialize which returns  a struct of type Init containing the settings, buffer, integration tables for the double-exponential formula and the variational Ansatz s.t. everything needed for the optimization is saved in one variable, which can then be passed to the optimizer.","category":"page"},{"location":"functionality/#In-short","page":"Functionality","title":"In short","text":"","category":"section"},{"location":"functionality/","page":"Functionality","title":"Functionality","text":"Choose a lattice model and use its corresponding constructor (e.g. XXZ for XXZ-model).\nChoose a variational Ansatz (e.g. H_A_BW for an Ansatz corresponding to the Bisognano-Wichmann-theorem).\nWrap it all up in the initializer function initialize.\nPass the returned struct form step 3 together with initial parameters to the optimizer and run the optimizer.","category":"page"},{"location":"functionality/#Example","page":"Functionality","title":"Example","text":"","category":"section"},{"location":"functionality/","page":"Functionality","title":"Functionality","text":"Finding the optimal parameters for the TFIM with N=10, N_A =5, Γ=1 with an maximum integration time of T_max=1.5 with OBC (default) with H_A_BW as an variational ansatz.","category":"page"},{"location":"functionality/","page":"Functionality","title":"Functionality","text":"using QuantVarEntHam\n\ninit = initialize(TFIM(10, 5, 1., 1.5), H_A_BW)\ng_init = [1.,2.,3.,4.,5.]\noptimize_LBFGS(g_init, init, gtol = 1e-16, maxiter = 100, print_result = false, show_trace = false)\n\n# output\nDiagonalizing the Hamitlonian via exact diagonalization for constructing the ground state density matrix\ng_init: [1.0, 2.0, 3.0, 4.0, 5.0]\nN: 10\nN_A: 5\nT_max: 1.5\n([0.7998845505676324, 2.339898908834232, 3.4440561575399675, 3.9916008402215475, 4.146669334126589], 1.0913856563696261e-5)","category":"page"},{"location":"functionality/","page":"Functionality","title":"Functionality","text":"The output ","category":"page"},{"location":"functionality/","page":"Functionality","title":"Functionality","text":"Diagonalizing the Hamitlonian via exact diagonalization for constructing the ground state density matrix","category":"page"},{"location":"functionality/","page":"Functionality","title":"Functionality","text":"stems from the function get_rhoA giving a hint which method is used to extract the ground state. The optimizer prints the most important underlying settings once and the  real output  is ","category":"page"},{"location":"functionality/","page":"Functionality","title":"Functionality","text":"([0.7998845505676324, 2.339898908834232, 3.4440561575399675, 3.9916008402215475, 4.146669334126589], 1.0913856563696261e-5)","category":"page"},{"location":"functionality/","page":"Functionality","title":"Functionality","text":"The vector corresponds to the optimal parameters and the second element in the tuple is the cost function value at its minimum","category":"page"},{"location":"hamiltonians/#Hamiltonians","page":"Hamiltonians","title":"Hamiltonians","text":"","category":"section"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"H_XXZ(N::Int, Δ::Real; periodic::Bool=false, signHam::Integer = +1)","category":"page"},{"location":"hamiltonians/#QuantVarEntHam.H_XXZ-Tuple{Int64, Real}","page":"Hamiltonians","title":"QuantVarEntHam.H_XXZ","text":"H_XXZ(N::Int,  Δ::Real; periodic::Bool=false, signHam::Integer = +1)\n\nReturn the XXZ Hamiltonian H=sum_i=1^N-1( X_iX_i+1 + Y_iY_i+1 + Δ Z_iZ_i+1) with N sites and Anisotropy Δ as an AbstractBlock.\n\nSet periodic as true for PBC or as false for OBC and signHam for a global sign.\n\n\n\n\n\n","category":"method"},{"location":"hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"H_TFIM(N::Int, Γ::Real; periodic::Bool=false, signHam::Integer = -1)","category":"page"},{"location":"hamiltonians/#QuantVarEntHam.H_TFIM-Tuple{Int64, Real}","page":"Hamiltonians","title":"QuantVarEntHam.H_TFIM","text":"H_TFIM(N::Int, Γ::Real; periodic::Bool=false, signHam::Integer = -1)\n\nReturn the TFIM Hamiltonian H=sum_i=1^N-1 Z_iZ_i+1 + Γ sum_i=1^N X_i with N sites and transversal field Γ as an AbstractBlock.\n\nSet periodic as true for PBC or as false for OBC and signHam for a global sign.\n\n\n\n\n\n","category":"method"},{"location":"settings/#Settings","page":"Settings","title":"Settings","text":"","category":"section"},{"location":"settings/","page":"Settings","title":"Settings","text":"Settings{T<:AbstractBlock,S<:AbstractMatrix} ","category":"page"},{"location":"settings/#QuantVarEntHam.Settings","page":"Settings","title":"QuantVarEntHam.Settings","text":"Settings{T<:AbstractBlock,S<:AbstractMatrix}\n\nAbstract type to dispatch on the concrete types for the correct variational Ansätze.\n\nThe parametric type T<:AbstractBlock is introduced for determining the correct concrete type of the Yao Blocks, while  S<:AbstractMatrix is needed to determine the concrete type of the matrix representation of the Yao Blocks to prevent  working with full complex dense matrices.\n\n\n\n\n\n","category":"type"},{"location":"settings/","page":"Settings","title":"Settings","text":"Settings_XXZ","category":"page"},{"location":"settings/#QuantVarEntHam.Settings_XXZ","page":"Settings","title":"QuantVarEntHam.Settings_XXZ","text":"Settings_XXZ{T<:AbstractBlock, S<:AbstractMatrix} <:Settings{T,S}\n\nContains the settings for the XXZ model\n\nThe parametric type T<:AbstractBlock is introduced for determining the correct concrete type of the Yao Blocks, while  S<:AbstractMatrix is needed to determine the concrete type of the matrix representation of the Yao Blocks to prevent  working with full complex dense matrices.\n\ntip: Tip\nUse the constructor XXZ to instantiate this struct since the types for observables and its matrices mtrxObs are automatically inferred then and the default values in XXZ are highly recommended.\n\nFields\n\nN::Int: number of sites in composite system.\nN_A::Int: number of sites in subsystem A.\nΔ::Float64: Anisotropy.\nT_max::Float64: maximum time for evolving the observables i.e. maximum integration time.\nr_max::Int: range of interaction (1 for nearest neighbour, 2 for next nearest neighbour, etc..) rmax = NA-1 corresponds to maximum order.\nperiodic::Bool: boundary conditions for the system Hamitlonian, false for open and true for periodic boundary conditions, obsolete if an own reduced density matrix ρ_A is provided.\nρ_A::DensityMatrix{2, ComplexF64, Matrix{ComplexF64}}: reduced density matrix of ground state of the composite system on subsystem A.\nobservables::Vector{T}: monitored observables in the cost function.\nmeas0::Vector{Float64} = [expect(observables[i], ρ_A) for i in eachindex(observables)]: expectation values of observables at time t=0.\nmtrxObs::Vector{S}: matrix representations for the observables\natol::Float64=0.0: absolute tolerance for the integrator.\nrtol::Float64=atol>0 ? 0.: sqrt(eps(Float64)): relative tolerance for the integrator.\ndt::Float64=0.01: time step for evaluating the cost function via midpoint rule, obsolete if other integration techniques are used.\n\n\n\n\n\n","category":"type"},{"location":"settings/","page":"Settings","title":"Settings","text":"XXZ(N::Int, N_A::Int, Δ::Real, T_max::Real; r_max::Int=1, periodic::Bool = false, atol::Real=0.0, rtol::Real=atol>0 ? 0. : sqrt(eps(Float64)),\n    signHam::Integer=+1, ρ_A::DensityMatrix{2}=get_rhoA(H_XXZ(N, Δ, periodic=periodic, signHam=signHam),  N-N_A+1:N, N),\n    observables::Vector{<:AbstractBlock}=[repeat(N_A, Z, (i,i+1)) for i in 1:N_A-1], dt::Float64 = 0.01)","category":"page"},{"location":"settings/#QuantVarEntHam.XXZ-Tuple{Int64, Int64, Real, Real}","page":"Settings","title":"QuantVarEntHam.XXZ","text":"XXZ(N::Int, N_A::Int, Δ::Real, T_max::Real; r_max::Int=1, periodic::Bool = false, atol::Real=0.0, rtol::Real=atol>0 ? 0. : sqrt(eps(Float64)),\nsignHam::Integer=+1, ρ_A::DensityMatrix{2}=get_rhoA(H_XXZ(N, Δ, periodic=periodic, signHam=signHam), N-N_A+1:N, N),\nobservables::Vector{<:AbstractBlock}=[repeat(N_A, Z, (i,i+1)) for i in 1:N_A-1], dt::Float64 = 0.01)\n\nConvenient constructor for Settings_XXZ containing settings for the XXZ Model \n\nRequired Arguments\n\nN::Int: number of sites in the composite system.\nΔ::Real: Anisotropy \nN_A::Int: number of sites in subsystem A.\nT_max::Real: maximum time for evolving the observables i.e. maximum integration time.\n\nKeyword arguments\n\nr_max::Int=1: range of interaction (1 for nearest neighbour, 2 for next nearest neighbour, etc..) rmax = NA-1 corresponds to maximum order.\nperiodic::Bool=false: boundary conditions for the system Hamitlonian, false for open and true for periodic boundary conditions, obsolete if an own reduced density matrix ρ_A is provided.\natol::Real=0.0: absolute tolerance for the integrator.\nrtol::Real=atol>0 ? 0.: sqrt(eps(Float64)): relative tolerance for the integrator.\nsignHam::Integer=1: global sign of Hamiltonian, obsolete if an own reduced density matrix ρ_A is provided.\nρ_A::DensityMatrix{2}=get_rhoA(H_XXZ(N, Δ, periodic=periodic, signHam=signHam), N-N_A+1:N, N): reduced density matrix of ground state of the composite system on subsystem A, by default the subsystem is on the right border.\nobservables::Vector{<:AbstractBlock}=[repeat(N_A, Z, (i,i+1)) for i in 1:N_A-1]: monitored observables in the cost function.\ndt::Real=0.01: time step for evaluating the cost function via midpoint rule, obsolete if other integration techniques are used.\n\nRecommendations\n\nuse only Z-gates (or composition of these) as observables since these are diagonal thus save computation time the most.\nuse only one type of observables (e.g. Xi Xi+1) since these are then stored as sparse or diagonal matrices, otherwise dense which leads to higher computation time.\nbe carefull when changing the tolerances for integration (not recommended), a relative tolerance higher than ≈ 1e-7 is not recommended since this can lead to wrong results.\n\n\n\n\n\n","category":"method"},{"location":"settings/","page":"Settings","title":"Settings","text":"Settings_TFIM","category":"page"},{"location":"settings/#QuantVarEntHam.Settings_TFIM","page":"Settings","title":"QuantVarEntHam.Settings_TFIM","text":"Settings_TFIM{T<:AbstractBlock, S<:AbstractMatrix} <:Settings{T,S}\n\nContains the settings for the TFIM\n\nThe parametric type T<:AbstractBlock is introduced for determining the correct concrete type of the Yao Blocks, while  S<:AbstractMatrix is needed to determine the concrete type of the matrix representation of the Yao Blocks to prevent  working with full complex dense matrices.\n\ntip: Tip\nUse the constructor TFIM to instantiate this struct since the types for observables and its matrices mtrxObs are automatically inferred then and the default values in TFIM are highly recommended.\n\nFields\n\nN::Int: number of sites in composite system.\nN_A::Int: number of sites in subsystem A.\nΓ::Float64: Anisotropy.\nT_max::Float64: maximum time for evolving the observables i.e. maximum integration time.\nr_max::Int: range of interaction (1 for nearest neighbour, 2 for next nearest neighbour, etc..) rmax = NA-1 corresponds to maximum order.\nperiodic::Bool: boundary conditions for the system Hamitlonian, false for open and true for periodic boundary conditions, obsolete if an own reduced density matrix ρ_A is provided.\nρ_A::DensityMatrix{2, ComplexF64, Matrix{ComplexF64}}: reduced density matrix of ground state of the composite system on subsystem A.\nobservables::Vector{T}: monitored observables in the cost function.\nmeas0::Vector{Float64} = [expect(observables[i], ρ_A) for i in eachindex(observables)]: expectation values of observables at time t=0.\nmtrxObs::Vector{S}: matrix representations for the observables\natol::Float64=0.0: absolute tolerance for the integrator.\nrtol::Float64=atol>0 ? 0.: sqrt(eps(Float64)): relative tolerance for the integrator.\ndt::Float64=0.01: time step for evaluating the cost function via midpoint rule, obsolete if other integration techniques are used. \n\n\n\n\n\n","category":"type"},{"location":"settings/","page":"Settings","title":"Settings","text":"TFIM(N::Int, N_A::Int, Γ::Real, T_max::Real; r_max::Int=1, periodic::Bool=false, atol::Real=0.0, rtol::Real=atol>0 ? 0. : sqrt(eps(Float64)),\n    signHam::Integer=-1, ρ_A::DensityMatrix{2}=get_rhoA(H_TFIM(N, Γ, periodic = periodic, signHam=signHam), N-N_A+1:N, N),\n    observables::Vector{<:AbstractBlock}=[repeat(N_A, Z, (i,i+1)) for i in 1:N_A-1], dt::Real=0.01) ","category":"page"},{"location":"settings/#QuantVarEntHam.TFIM-Tuple{Int64, Int64, Real, Real}","page":"Settings","title":"QuantVarEntHam.TFIM","text":"TFIM(N::Int, N_A::Int, Γ::Real, T_max::Real; r_max::Int=1, periodic::Bool=false, atol::Real=0.0, rtol::Real=atol>0 ? 0. : sqrt(eps(Float64)),\nsignHam::Integer=-1, ρ_A::DensityMatrix{2}=get_rhoA(H_TFIM(N, Γ, periodic = periodic, signHam=signHam), N-N_A+1:N, N),\nobservables::Vector{<:AbstractBlock}=[repeat(N_A, Z, (i,i+1)) for i in 1:N_A-1], dt::Real=0.01)\n\nConvenient constructor for Settings_TFIM containing settings for the Transversal Field Ising Model\n\nRequired Arguments\n\nN::Int: number of sites in the composite system.\nΓ::Real: transversal field strength \nN_A::Int: number of sites in subsystem A.\nT_max::Real: maximum time for evolving the observables i.e. maximum integration time.\n\nKeyword arguments\n\nr_max::Int=1: range of interaction (1 for nearest neighbour, 2 for next nearest neighbour, etc..) rmax = NA-1 corresponds to maximum order.\nperiodic::Bool=false: boundary conditions for the system Hamitlonian, false for open and true for periodic boundary conditions.\natol::Real=0.0: absolute tolerance for the integrator.\nrtol::Real=atol>0 ? 0.: sqrt(eps(Float64)): relative tolerance for the integrator.\nsignHam::Integer=-1: global sign of Hamiltonian, obsolete if an own reduced density matrix ρ_A is provided.\nρ_A::DensityMatrix{2}=get_rhoA(H_TFIM(N, Γ, periodic = periodic, signHam=signHam), N-N_A+1:N, N): reduced density matrix of ground state of the composite system on subsystem A, by default the subsystem is on the right border.\nobservables::Vector{<:AbstractBlock}=[repeat(N_A, Z, (i,i+1)) for i in 1:N_A-1]: monitored observables in the cost function.\ndt::Real=0.01: time step for evaluating the cost function via midpoint rule, obsolete if other integration techniques are used.\n\nRecommendations\n\nuse only Z-gates (or composition of these) as observables since these are diagonal thus save computation time the most. \nuse only one type of observables (e.g. Xi Xi+1) since these are then stored as sparse matrices, otherwise dense which leads to higher computation time.\nbe carefull when changing the tolerances for integration (not recommended), a relative tolerance higher than ≈ 1e-7 is not recommended since this can lead to wrong results.\n\n\n\n\n\n","category":"method"},{"location":"#QuantVarEntHam.jl-Documentation","page":"Home","title":"QuantVarEntHam.jl Documentation","text":"","category":"section"},{"location":"initialize/#Initialize","page":"Initialize","title":"Initialize","text":"","category":"section"},{"location":"initialize/","page":"Initialize","title":"Initialize","text":"Init{T<:Settings, S<:AbstractMatrix}","category":"page"},{"location":"initialize/#QuantVarEntHam.Init","page":"Initialize","title":"QuantVarEntHam.Init","text":"Init{T<:Settings, S<:AbstractMatrix}\n\nWIP\n\n\n\n\n\n","category":"type"},{"location":"initialize/","page":"Initialize","title":"Initialize","text":"initialize(Model::Settings, H_A::Function)","category":"page"},{"location":"initialize/#QuantVarEntHam.initialize-Tuple{Settings, Function}","page":"Initialize","title":"QuantVarEntHam.initialize","text":"initialize(Model::Settings, H_A::Function)\n\nWIP\n\n\n\n\n\n","category":"method"},{"location":"initialize/","page":"Initialize","title":"Initialize","text":"get_rhoA(H::AbstractBlock, A::AbstractVector{Int}, N::Int) ","category":"page"},{"location":"initialize/#QuantVarEntHam.get_rhoA-Tuple{AbstractBlock, AbstractVector{Int64}, Int64}","page":"Initialize","title":"QuantVarEntHam.get_rhoA","text":"get_rhoA(H::AbstractBlock, A::AbstractVector{Int}, N::Int)\n\nReturn the reduced density matrix of type YaoAPI.DensityMatrix of the ground state of Hamitlonian H for N sites on subsystem A.\n\nFor composite systems consisting of more than 10 sites, the krylov subspace method from KrylovKit is used for  extracting the ground state.\n\n\n\n\n\n","category":"method"},{"location":"optimizer/#Optimizer","page":"Optimizer","title":"Optimizer","text":"","category":"section"},{"location":"optimizer/","page":"Optimizer","title":"Optimizer","text":"optimize_LBFGS(g_init::Vector{<:AbstractFloat}, init::Init; g1::AbstractFloat=NaN, gtol::AbstractFloat=1e-12, maxiter::Integer = 200, show_trace::Bool=true)","category":"page"},{"location":"optimizer/#QuantVarEntHam.optimize_LBFGS-Tuple{Vector{<:AbstractFloat}, Init}","page":"Optimizer","title":"QuantVarEntHam.optimize_LBFGS","text":"optimize_LBFGS(g_init::Vector{<:AbstractFloat}, init::Init; g1::AbstractFloat=NaN, gtol::AbstractFloat=1e-12, maxiter::Integer = 200, show_trace::Bool=true, print_result::Bool = true)\n\nMinimize cost function using the LBFGS-optimizer from Optim.jl.\n\nRequired arguments\n\ng_init::Vector{<:AbstractFloat}: initial parameters.\ninit::Init: struct containing settings, variational Ansatz, buffers and integration table for tanh-sinh integration.\n\nKeyword arguments\n\ng1::AbstractFloat=NaN: provide number if the first parameter should be fixed.\ngtol::AbstractFloat=1e-12: maximum gradient norm in order to stop minimizing.\nmaxiter::Integer = 200: maximum number of iterations in order to stop minimizing.\nshow_trace::Bool=true: true for showing the trace of the minizing procedure, false otherwise.\nprint_result::Bool = true true to print optimal parameters, false otherwise \n\n\n\n\n\n","category":"method"}]
}
